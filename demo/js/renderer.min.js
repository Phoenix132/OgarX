(function(){function b(d,e,g){function a(j,i){if(!e[j]){if(!d[j]){var f="function"==typeof require&&require;if(!i&&f)return f(j,!0);if(h)return h(j,!0);var c=new Error("Cannot find module '"+j+"'");throw c.code="MODULE_NOT_FOUND",c}var k=e[j]={exports:{}};d[j][0].call(k.exports,function(b){var c=d[j][1][b];return a(c||b)},k,k.exports,b,d,e,g)}return e[j].exports}for(var h="function"==typeof require&&require,c=0;c<g.length;c++)a(g[c]);return a}return b})()({1:[function(a,b){var c=String.fromCharCode;b.exports=class{constructor(a,b=!0){this.view=a,this.offset=0,this.le=b}get length(){return this.view.byteLength}readUInt8(){return this.view.getUint8(this.offset++)}readInt8(){return this.view.getInt8(this.offset++)}readUInt16(){const b=this.view.getUint16(this.offset,this.le);return this.offset+=2,b}readInt16(){const b=this.view.getUint16(this.offset,this.le);return this.offset+=2,b}readUInt32(){const b=this.view.getUint32(this.offset,this.le);return this.offset+=4,b}readInt32(){const b=this.view.getInt32(this.offset,this.le);return this.offset+=4,b}readFloat32(){const b=this.view.getFloat32(this.offset,this.le);return this.offset+=4,b}readFloat64(){const b=this.view.getFloat64(this.offset,this.le);return this.offset+=8,b}skip(a){this.offset+=a}readUTF8String(){const a=[];for(;this.offset<this.view.byteLength;){const b=this.readUInt8();if(!b)break;a.push(c(b))}return a.join("")}readUTF16String(){const a=[];for(;this.offset<this.view.byteLength;){const b=this.readUInt16();if(!b)break;a.push(c(b))}return a.join("")}}},{}],2:[function(a,b){const c=new DataView(new ArrayBuffer(1048576));b.exports=class{constructor(a=!0){this.offset=0,this.le=a}writeUInt8(b){c.setUint8(this.offset++,b)}writeInt8(b){c.setInt8(this.offset++,b)}writeUInt16(b){c.setUint16(this.offset,b,this.le),this.offset+=2}writeInt16(b){c.setInt16(this.offset,b,this.le),this.offset+=2}writeUInt32(b){c.setUint32(this.offset,b,this.le),this.offset+=4}writeInt32(b){c.setInt32(this.offset,b,this.le),this.offset+=4}writeFloat32(b){c.setFloat32(this.offset,b,this.le),this.offset+=4}writeFloat64(b){c.setFloat64(this.offset,b,this.le),this.offset+=8}writeUTF8String(b){for(let a=0;a<b.length;a++)this.writeUInt8(b.charCodeAt(a));this.writeUInt8(0)}writeUTF16String(b){for(let a=0;a<b.length;a++)this.writeUInt16(b.charCodeAt(a));this.writeUInt16(0)}finalize(){return c.buffer.slice(0,this.offset)}}},{}],3:[function(a,b){b.exports=class{constructor(a,b){this.view=a,this.id=b}get type(){return this.view.getUint32(0,!0)}get oldX(){return this.view.getFloat32(4,!0)}get oldY(){return this.view.getFloat32(8,!0)}get oldSize(){return this.view.getFloat32(12,!0)}get currX(){return this.view.getFloat32(16,!0)}get currY(){return this.view.getFloat32(20,!0)}get currSize(){return this.view.getFloat32(24,!0)}get netX(){return this.view.getFloat32(28,!0)}get netY(){return this.view.getFloat32(32,!0)}get netSize(){return this.view.getFloat32(36,!0)}toString(){return`Cell#${this.id} [type: ${this.type}, x: ${this.netX}, y: ${this.netY}, size: ${this.netSize}]`}toObject(){return{type:this.type,oldX:this.oldX,oldY:this.oldY,oldSize:this.oldSize,currX:this.currX,currY:this.currY,currSize:this.currSize,netX:this.netX,netY:this.netY,netSize:this.netSize}}}},{}],4:[function(a,b){b.exports=class{constructor(a){this.port=a,this.readyState=WebSocket.OPEN,a.onmessage=a=>{const{data:b}=a;"message"===b.event?this.onmessage({data:b.message}):"error"===b.event?this.onerror({message:b.message}):"close"===b.event?this.onclose({code:b.code,reason:b.message}):"open"===b.event&&this.onopen()},a.start(),this.onopen=this.onmessage=this.onerror=this.onclose=()=>{}}send(a){this.port.postMessage({event:"message",message:a},[a])}close(){this.port.postMessage({event:"close",code:1001,message:"Client closed connection"}),this.port.close()}}},{}],5:[function(a,b){b.exports=class{constructor(){this.setBuffer()}setBuffer(a=new SharedArrayBuffer(12)){this.sharedBuffer=a,this.buffer=new Int32Array(this.sharedBuffer)}get x(){return Atomics.load(this.buffer,0)}set x(a){Atomics.store(this.buffer,0,a)}get y(){return Atomics.load(this.buffer,1)}set y(a){Atomics.store(this.buffer,1,a)}get scroll(){return Atomics.load(this.buffer,2)}set scroll(a){Atomics.store(this.buffer,2,a)}updateScroll(a){Atomics.add(this.buffer,2,a)}resetScroll(){return Atomics.exchange(this.buffer,2,0)}}},{}],6:[function(a,b){const c=a("../../src/network/reader"),d=a("../../src/network/writer"),e=a("./fake-socket");b.exports=class{constructor(a){this.pid=0,this.bandwidth=0,this.renderer=a,this.pingInterval=self.setInterval(()=>{const a=new ArrayBuffer(1);new Uint8Array(a)[0]=69,this.send(a),this.bandwidth=0},1e3);const b=this.renderer.state;this.mouseInterval=self.setInterval(()=>{const a=new d;a.writeUInt8(3),a.writeFloat32(this.renderer.cursor.position[0]),a.writeFloat32(this.renderer.cursor.position[1]);const c=b.exchange();a.writeUInt8(c.spectate),a.writeUInt8(c.splits),a.writeUInt8(c.ejects),a.writeUInt8(c.macro),this.send(a.finalize()),c.respawn&&this.spawn()},1e3/30)}connect(a){this.disconnect(),this.ws="string"==typeof a?new WebSocket(a):new e(a),this.ws.binaryType="arraybuffer",this.ws.onopen=()=>{console.log("Connected to server");const a=new d;a.writeUInt8(69),a.writeInt16(420),this.ws.send(a.finalize())},this.ws.onmessage=a=>{const b=new c(new DataView(a.data)),d=b.readUInt8();switch(this.bandwidth+=a.data.byteLength,d){case 1:this.pid=b.readUInt16();const c={width:2*b.readUInt16(),height:2*b.readUInt16()};console.log(`PID: ${this.pid}, MAP: [${c.width}, ${c.height}]`);const e=this.renderer.randomPlayer();this.spawn(e.name,e.skin);break;case 2:console.log("Clear map"),this.renderer.clearCells();break;case 3:const f=b.readUInt16(),g=b.readUTF16String(),h=b.readUTF16String();console.log(`Received player data`,{id:f,name:g,skin:h}),this.renderer.loadPlayerData({id:f,name:g,skin:h});break;case 4:this.parseCellData(a.data);}},this.ws.onerror=a=>console.error(a),this.ws.onclose=a=>console.error(a.code,a.reason)}send(a){this.ws&&this.ws.readyState==WebSocket.OPEN&&this.ws.send(a)}parseCellData(a){this.lastPacket=Date.now();const b=this.renderer.core,c=new DataView(a,1,8);this.renderer.target.position[0]=c.getFloat32(0,!0),this.renderer.target.position[1]=c.getFloat32(4,!0),b.HEAPU8.set(new Uint8Array(a,9),this.renderer.cellTypesTableOffset),b.instance.exports.deserialize(0,this.renderer.cellTypesTableOffset)}disconnect(){this.ws&&this.ws.close(),this.ws=null}spawn(a=this.lastName,b=this.lastSkin){this.lastName=a,this.lastSkin=b;const c=new d;c.writeUInt8(1),c.writeUTF16String(a),c.writeUTF16String(b),this.send(c.finalize())}}},{"../../src/network/reader":1,"../../src/network/writer":2,"./fake-socket":4}],7:[function(a,b){importScripts("https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js");const c=a("./cell"),d=a("./mouse"),e=a("./state"),f=a("./viewport"),g=a("./protocol"),h=a("./wasm-core"),{makeProgram:i,pick:j,getColor:k}=a("./util"),{CELL_VERT_SHADER_SOURCE:l,CELL_FRAG_PEELING_SHADER_SOURCE:m,NAME_VERT_SHADER_SOURCE:n,NAME_FRAG_PEELING_SHADER_SOURCE:o,MASS_VERT_SHADER_SOURCE:p,MASS_FRAG_PEELING_SHADER_SOURCE:q,QUAD_VERT_SHADER_SOURCE:r,BLEND_BACK_FRAG_SHADER_SOURCE:s,FINAL_FRAG_SHADER_SOURCE:t}=a("./shaders"),u=0,v=.25,z=-.33,A=256,B=65536,C=30,D=65536,E=-99999,F=["0","1","2","3","4","5","6","7","8","9",".","k"],G=F.length;class H{constructor(a){this.canvas=a,this.cursor={position:vec3.create()},this.target={position:vec3.create(),scale:10},this.camera={position:vec3.create(),scale:10},this.fbo=new Map,this.buffers=new Map,this.uniforms=new Map,this.players=new Map,this.updates=new Map,this.mouse=new d,this.state=new e,this.viewport=new f,this.core=new h(this),this.proj=mat4.create(),this.viewbox={t:0,b:0,l:0,r:0},this.initLoader(),this.drawCells=this.drawCells.bind(this),this.drawNames=this.drawNames.bind(this),this.drawMass=this.drawMass.bind(this)}start(){if(this.r)return!1;const a=b=>{this.r=requestAnimationFrame(a);try{this.render(b)}catch(a){this.stop(),console.error(a)}};return this.r=requestAnimationFrame(a),!0}stop(){return!!this.r&&(this.r=cancelAnimationFrame(this.r),!0)}loadPlayerData(a){this.loader.postMessage(a)}initLoader(){this.loader=new Worker("loader.min.js"),this.loader.onmessage=a=>this.updates.set(a.data.id,[a.data.skin,a.data.name])}loadUniform(a,b){this.uniforms.has(a)||this.uniforms.set(a,new Map),this.uniforms.get(a).set(b,this.gl.getUniformLocation(a,b))}getUniform(a,b){return this.uniforms.get(a).get(b)}async initEngine(){const a=this.gl=this.canvas.getContext("webgl2",{premultipliedAlpha:!1,powerPreference:"high-performance"});if(!a)return console.error("WebGL2 Not Supported");console.log("Loading WASM..."),await this.core.load(),console.log("Loading font");let b=new FontFace("Bree Serif","url(/static/font/BreeSerif-Regular.ttf)");fonts.add(b),await b.load(),b=new FontFace("Bree Serif","url(/static/font/Lato-Bold.ttf)"),fonts.add(b),await b.load(),console.log("Loading bot skins & names");const d=await fetch("/static/data/bots.json");if(this.bots=await d.json(),this.BYTES_PER_CELL_DATA=this.core.instance.exports.bytes_per_cell_data(),this.BYTES_PER_RENDER_CELL=this.core.instance.exports.bytes_per_render_cell(),this.cells=Array.from({length:B},(a,b)=>new c(new DataView(this.core.buffer,b*this.BYTES_PER_CELL_DATA,this.BYTES_PER_CELL_DATA),b)),this.cellTypesTableOffset=B*this.BYTES_PER_CELL_DATA,console.log(`Table offset: ${this.cellTypesTableOffset}`),this.cellBufferOffset=this.cellTypesTableOffset+2*A,console.log(`Render buffers offset: ${this.cellBufferOffset}`),this.cellBufferEnd=this.cellBufferOffset+B*this.BYTES_PER_RENDER_CELL,console.log(`Render buffer end ${this.cellBufferEnd}`),this.nameBufferOffset=this.cellBufferEnd+2*A,this.nameBufferEnd=this.nameBufferOffset+B*this.BYTES_PER_RENDER_CELL,console.log(`Memory allocated: ${this.core.buffer.byteLength} bytes`),this.cellTypesTable=new Uint16Array(this.core.buffer,this.cellTypesTableOffset,A),this.nameTypesTable=new Uint16Array(this.core.buffer,this.cellBufferEnd,A),this.renderBuffer=this.core.HEAPU8.subarray(this.cellBufferOffset,this.cellBufferEnd),this.renderBufferView=new DataView(this.core.buffer,this.cellBufferOffset,B*this.BYTES_PER_RENDER_CELL),this.massWidthsTable=new Map,this.massBuffer=new Float32Array(new ArrayBuffer(128*B)),!a.getExtension("EXT_color_buffer_float"))return void console.error("FLOAT color buffer not available");a.enable(a.BLEND),a.depthMask(!1),a.disable(a.DEPTH_TEST),a.disable(a.CULL_FACE),a.blendFunc(a.ONE,a.ONE_MINUS_SRC_ALPHA);const e=this.peel_prog1=i(a,l,m),f=this.peel_prog2=i(a,n,o),h=this.peel_prog3=i(a,p,q),j=this.blend_prog=i(a,r,s),k=this.final_prog=i(a,r,t);for(const a of[e,f,h])this.loadUniform(a,"u_proj"),this.loadUniform(a,"u_depth"),this.loadUniform(a,"u_front_color");this.loadUniform(e,"u_skin"),this.loadUniform(e,"u_circle"),this.loadUniform(e,"u_circle_color"),this.loadUniform(f,"u_dim"),this.loadUniform(f,"u_name"),this.loadUniform(h,"u_uvs"),this.loadUniform(h,"u_mass_char"),this.loadUniform(j,"u_back_color"),this.loadUniform(k,"u_front_color"),this.loadUniform(k,"u_back_color"),this.setUpPeelingBuffers(),this.generateQuadVAO(),this.generateMassVAO(),this.generateCircleTexture(),this.generateMassTextures(),this.allocBuffer("cell_data_buffer"),a.bindVertexArray(this.quadVAO),a.bindBuffer(a.ARRAY_BUFFER,this.buffers.get("cell_data_buffer")),a.bufferData(a.ARRAY_BUFFER,this.renderBuffer,a.DYNAMIC_DRAW),a.vertexAttribPointer(1,3,a.FLOAT,!1,0,0),a.vertexAttribDivisor(1,2),a.enableVertexAttribArray(1),a.useProgram(e),a.uniform1i(this.getUniform(e,"u_circle"),10),a.uniform1i(this.getUniform(e,"u_skin"),11),a.useProgram(f),a.uniform1i(this.getUniform(f,"u_name"),12),a.useProgram(h),a.uniform1i(this.getUniform(h,"u_mass_char"),13),a.useProgram(k),a.uniform1i(this.getUniform(k,"u_back_color"),6),a.activeTexture(a.TEXTURE11),this.empty_texture=a.createTexture(),a.bindTexture(a.TEXTURE_2D,this.empty_texture),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,1,1,0,a.RGBA,a.UNSIGNED_BYTE,null),this.loadPlayerData({id:253,name:"virus",skin:"/static/img/virus.png"}),this.start(),this.protocol=new g(this)}clearCells(){this.core.HEAPU32.fill(0),this.massBuffer.fill(0)}randomPlayer(){return{skin:"",name:j(this.bots.names)}}async genCells(){for(let a=1;256>a;a++)this.loadPlayerData({id:a,...randomPlayer()});this.GEN_CELLS=65536;const a=new DataView(this.core.buffer,0,this.GEN_CELLS*this.BYTES_PER_CELL_DATA),b=(a,b)=>Math.random()*(b-a)+a;for(let c=0;c<this.GEN_CELLS;c++){const d=this.BYTES_PER_CELL_DATA*c,e=~~(255*Math.random()+1),f=~~b(-D,D)+e/10,g=~~b(-D,D)+e/10,h=b(C,C+200);a.setUint32(0+d,e,!0),a.setFloat32(4+d,f,!0),a.setFloat32(8+d,g,!0),a.setFloat32(12+d,h,!0),a.setFloat32(16+d,f,!0),a.setFloat32(20+d,g,!0),a.setFloat32(24+d,h,!0),a.setFloat32(28+d,f,!0),a.setFloat32(32+d,g,!0),a.setFloat32(36+d,h,!0)}}allocBuffer(a){if(this.buffers.has(a))throw new Error(`Already allocated buffer "${a}"`);const b=this.gl.createBuffer();return this.buffers.set(a,b),b}allocFrameBuffer(a,b=1){if(this.fbo.has(a))throw new Error(`Already allocated framebuffer "${a}"`);this.fbo.set(a,1==b?this.gl.createFramebuffer():Array.from({length:b},()=>this.gl.createFramebuffer()))}setUpPeelingBuffers(){this.allocFrameBuffer("peel_depths",2),this.allocFrameBuffer("peel_colors",2),this.allocFrameBuffer("blend_back");const a=this.gl,b=()=>{a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE)};for(let c=0;2>c;c++){a.bindFramebuffer(a.FRAMEBUFFER,this.fbo.get("peel_depths")[c]);const d=3*c,e=a.createTexture();a.activeTexture(a.TEXTURE0+d),a.bindTexture(a.TEXTURE_2D,e),b(),a.texImage2D(a.TEXTURE_2D,0,a.RG32F,1920,1080,0,a.RG,a.FLOAT,null),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0);const f=a.createTexture();a.activeTexture(a.TEXTURE1+d),a.bindTexture(a.TEXTURE_2D,f),b(),a.texImage2D(a.TEXTURE_2D,0,a.RGBA16F,1920,1080,0,a.RGBA,a.HALF_FLOAT,null),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT1,a.TEXTURE_2D,f,0);const g=a.createTexture();a.activeTexture(a.TEXTURE2+d),a.bindTexture(a.TEXTURE_2D,g),b(),a.texImage2D(a.TEXTURE_2D,0,a.RGBA16F,1920,1080,0,a.RGBA,a.HALF_FLOAT,null),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT2,a.TEXTURE_2D,g,0),a.bindFramebuffer(a.FRAMEBUFFER,this.fbo.get("peel_colors")[c]),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,f,0),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT1,a.TEXTURE_2D,g,0)}{a.bindFramebuffer(a.FRAMEBUFFER,this.fbo.get("blend_back"));const c=a.createTexture();a.activeTexture(a.TEXTURE6),a.bindTexture(a.TEXTURE_2D,c),b(),a.texImage2D(a.TEXTURE_2D,0,a.RGBA16F,1920,1080,0,a.RGBA,a.HALF_FLOAT,null),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,c,0),a.bindFramebuffer(a.FRAMEBUFFER,null)}}clearPeelingBuffers(){const a=this.gl;a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.fbo.get("blend_back")),a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.fbo.get("peel_depths")[0]),a.drawBuffers([a.COLOR_ATTACHMENT0]),a.clearColor(E,E,0,0),a.clear(a.COLOR_BUFFER_BIT),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.fbo.get("peel_depths")[1]),a.clearColor(-0,1,0,0),a.clear(a.COLOR_BUFFER_BIT),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.fbo.get("peel_colors")[0]),a.drawBuffers([a.COLOR_ATTACHMENT0,a.COLOR_ATTACHMENT1]),a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.fbo.get("peel_colors")[1]),a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.fbo.get("peel_depths")[0]),a.drawBuffers([a.COLOR_ATTACHMENT0]),a.blendEquation(a.MAX);for(const b of[this.peel_prog1,this.peel_prog2,this.peel_prog3])a.useProgram(b),a.uniform1i(this.getUniform(b,"u_depth"),3),a.uniform1i(this.getUniform(b,"u_front_color"),4)}generateQuadVAO(){const a=this.gl,b=this.quadVAO=a.createVertexArray();a.bindVertexArray(b);const c=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,c),a.bufferData(a.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,-1,-1,1,1,-1,1,1]),a.STATIC_DRAW);{const b=a.FLOAT;a.vertexAttribPointer(0,2,b,!1,0,0),a.enableVertexAttribArray(0)}}generateMassVAO(){const a=this.gl,b=this.massVAO=a.createVertexArray();a.bindVertexArray(b);const c=this.allocBuffer("mass_buffer");a.bindBuffer(a.ARRAY_BUFFER,c),a.bufferData(a.ARRAY_BUFFER,this.massBuffer,a.DYNAMIC_DRAW);{const b=a.FLOAT;a.vertexAttribPointer(0,4,b,!1,0,0),a.enableVertexAttribArray(0)}}generateCircleTexture(){const a=this.gl,b=a.createTexture();a.activeTexture(a.TEXTURE10),a.bindTexture(a.TEXTURE_2D,b);{console.log(`Generating ${4096}x${4096} circle texture`);const b=new OffscreenCanvas(4096,4096),c=b.getContext("2d");c.fillStyle="white",c.arc(2048,2048,2048-10,0,2*Math.PI,!1),c.fill(),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,b),a.generateMipmap(a.TEXTURE_2D),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR_MIPMAP_LINEAR)}}generateMassTextures(){console.log("Generating mass characters");const a=this.gl,b=a.createTexture();a.activeTexture(a.TEXTURE13),a.bindTexture(a.TEXTURE_2D_ARRAY,b);const c=320,d=320;{a.texImage3D(a.TEXTURE_2D_ARRAY,0,a.RGBA,c,d,G,0,a.RGBA,a.UNSIGNED_BYTE,null);const b=new OffscreenCanvas(c,d),e=b.getContext("2d");e.font="bold 280px Lato",e.fillStyle="white",e.strokeStyle="black",e.textAlign="center",e.lineWidth=30,e.textBaseline="middle";const f=new Float32Array(2*(4*G));for(let g=0;g<G;g++){const h=F[g];e.clearRect(0,0,b.width,b.height),e.strokeText(h,b.width>>1,b.height>>1),e.fillText(h,b.width>>1,b.height>>1);const i=(e.measureText(h).width+20)/b.width;this.massWidthsTable.set(h,i),a.texSubImage3D(a.TEXTURE_2D_ARRAY,0,0,0,g,c,d,1,a.RGBA,a.UNSIGNED_BYTE,b);const j=.5-i/2,k=.5+i/2,l=0,m=1;f[8*g+0]=j,f[8*g+1]=l,f[8*g+2]=k,f[8*g+3]=l,f[8*g+4]=j,f[8*g+5]=m,f[8*g+6]=k,f[8*g+7]=m}a.generateMipmap(a.TEXTURE_2D_ARRAY),a.texParameteri(a.TEXTURE_2D_ARRAY,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D_ARRAY,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D_ARRAY,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D_ARRAY,a.TEXTURE_MIN_FILTER,a.LINEAR_MIPMAP_LINEAR),a.useProgram(this.peel_prog3),a.uniform2fv(this.getUniform(this.peel_prog3,"u_uvs"),f)}}screenToWorld(a=vec3.create(),b=0,c=0){const d=mat4.create();mat4.invert(d,this.proj),vec3.transformMat4(a,[b,-c,0],d)}updateTarget(){this.screenToWorld(this.cursor.position,2*(this.mouse.x/this.viewport.width)-1,2*(this.mouse.y/this.viewport.height)-1),this.target.scale*=1+this.mouse.resetScroll()/1e3,this.target.scale=Math.max(this.target.scale,.01),this.target.scale=Math.min(this.target.scale,1e4)}lerpCamera(a=1/60,b){vec3.lerp(this.camera.position,this.camera.position,this.target.position,a),this.camera.scale+=(this.target.scale-this.camera.scale)*a*5;const c=b?b.x:this.camera.position[0],d=b?b.y:this.camera.position[1],e=this.viewport.width*this.camera.scale/2,f=this.viewport.height*this.camera.scale/2,g=this.viewbox;mat4.ortho(this.proj,g.l=c-e,g.r=c+e,g.b=d-f,g.t=d+f,0,1)}checkViewport(){const a=this.gl;(a.canvas.width!=this.viewport.width||a.canvas.height!=this.viewport.height)&&(a.canvas.width=this.viewport.width,a.canvas.height=this.viewport.height)}drawCells(){const a=this.gl;a.bindVertexArray(this.quadVAO),a.activeTexture(a.TEXTURE11);for(let b=1;b<A;b++){let c=this.cellTypesTable[b-1],d=this.cellTypesTable[b];if(c==d)continue;d||(d=65536);const e=this.cellBufferOffset+c*this.BYTES_PER_RENDER_CELL,f=new Float32Array(this.core.buffer,e,3*(d-c));if(253==b)a.uniform4f(this.getUniform(this.peel_prog1,"u_circle_color"),0,0,0,0);else if(251==b)a.uniform4f(this.getUniform(this.peel_prog1,"u_circle_color"),.5,.5,.5,.5);else{const c=k(b);a.uniform4f(this.getUniform(this.peel_prog1,"u_circle_color"),c[0],c[1],c[2],1)}const g=this.players.get(b)||{};a.bindTexture(a.TEXTURE_2D,g.skin||this.empty_texture),a.bindBuffer(a.ARRAY_BUFFER,this.buffers.get("cell_data_buffer")),a.bufferSubData(a.ARRAY_BUFFER,0,f),a.bindBuffer(a.ARRAY_BUFFER,null),a.drawArraysInstanced(a.TRIANGLES,0,6,2*(d-c))}}drawNames(){const a=this.gl;a.bindVertexArray(this.quadVAO),a.activeTexture(a.TEXTURE12);for(let b=1;b<A;b++){if(!this.players.has(b))continue;let c=this.nameTypesTable[b-1],d=this.nameTypesTable[b];if(c==d)continue;d||(d=65536);const e=this.players.get(b);if(!e.name||!e.name_dim)continue;const f=this.nameBufferOffset+c*this.BYTES_PER_RENDER_CELL,g=new Float32Array(this.core.buffer,f,3*(d-c));a.uniform4f(this.getUniform(this.peel_prog2,"u_dim"),e.name_dim[0],e.name_dim[1],.25,-.03),a.bindTexture(a.TEXTURE_2D,e.name),a.bindBuffer(a.ARRAY_BUFFER,this.buffers.get("cell_data_buffer")),a.bufferSubData(a.ARRAY_BUFFER,0,g),a.bindBuffer(a.ARRAY_BUFFER,null),a.drawArraysInstanced(a.TRIANGLES,0,6,2*(d-c))}}drawMass(){const a=this.gl;a.bindVertexArray(this.massVAO),a.bindBuffer(a.ARRAY_BUFFER,this.buffers.get("mass_buffer")),a.bufferSubData(a.ARRAY_BUFFER,0,this.renderMassBuffer),a.bindBuffer(a.ARRAY_BUFFER,null),a.drawArrays(a.TRIANGLES,0,this.renderMassBuffer.length>>2)}buildMassBuffer(a){let b=0;for(let c=0;c<a.length;c+=4){const d=a[c],e=a[c+1],f=a[c+2],g=Math.floor(a[c+3]).toString();let h=(g.length-1)*u*v;for(let a=0;a<g.length;a++)h+=v*this.massWidthsTable.get(g[a]);let j=-h/2;for(let a=0;a<g.length;a++){const c="."==g[a]?10:"k"==g[a]?11:~~g[a],h=this.massWidthsTable.get(g[a]),i=j*f,k=i+v*h*f,l=(+.5*v+z)*f,m=(-.5*v+z)*f;j+=v*h+u,this.massBuffer[b++]=d+i,this.massBuffer[b++]=e+l,this.massBuffer[b++]=f,this.massBuffer[b++]=4*c+0,this.massBuffer[b++]=d+k,this.massBuffer[b++]=e+l,this.massBuffer[b++]=f,this.massBuffer[b++]=4*c+1,this.massBuffer[b++]=d+i,this.massBuffer[b++]=e+m,this.massBuffer[b++]=f,this.massBuffer[b++]=4*c+2,this.massBuffer[b++]=d+k,this.massBuffer[b++]=e+l,this.massBuffer[b++]=f,this.massBuffer[b++]=4*c+1,this.massBuffer[b++]=d+i,this.massBuffer[b++]=e+m,this.massBuffer[b++]=f,this.massBuffer[b++]=4*c+2,this.massBuffer[b++]=d+k,this.massBuffer[b++]=e+m,this.massBuffer[b++]=f,this.massBuffer[b++]=4*c+3}}this.renderMassBuffer=this.massBuffer.subarray(0,b)}render(a){if(!this.lastTimestamp)return void(this.lastTimestamp=a);const b=a-this.lastTimestamp;this.lastTimestamp=a,this.cellTypesTable.fill(0),this.nameTypesTable.fill(0);const c=this.protocol.lastPacket?(Date.now()-this.protocol.lastPacket)/120:0,d=this.core.instance.exports.draw_cells(0,this.cellTypesTableOffset,this.cellBufferOffset,c,this.viewbox.t,this.viewbox.b,this.viewbox.l,this.viewbox.r);let e=0;this.updateTarget();if(this.lerpCamera(b/120,null),this.checkViewport(),!this.state.focused)return void this.updateTextures();const f=this.gl;f.viewport(0,0,f.drawingBufferWidth,f.drawingBufferHeight);let g;this.clearPeelingBuffers();const h=[this.peel_prog1],i=[this.drawCells];e=this.core.instance.exports.draw_text(0,this.cellTypesTableOffset,this.cellBufferEnd,this.nameBufferOffset,this.nameBufferEnd,.03,this.viewbox.t,this.viewbox.b,this.viewbox.l,this.viewbox.r),h.push(this.peel_prog2),i.push(this.drawNames),this.buildMassBuffer(new Float32Array(this.core.buffer,this.nameBufferEnd,4*e)),h.push(this.peel_prog3),i.push(this.drawMass),g=this.depthPeelRender(2,h,i),this.log&&console.log(`Drawing ${e} text, ${d} cells`),f.bindFramebuffer(f.FRAMEBUFFER,null),f.clearColor(0,0,0,1),f.clear(f.COLOR_BUFFER_BIT),f.blendFunc(f.ONE,f.ONE_MINUS_SRC_ALPHA),f.useProgram(this.final_prog),f.uniform1i(this.getUniform(this.final_prog,"u_front_color"),g+1),f.bindVertexArray(this.quadVAO),f.drawArrays(f.TRIANGLES,0,6),this.updateTextures()}updateTextures(){const a=this.gl;if(this.updates.size){a.activeTexture(a.TEXTURE11);let b=0;for(const[a,c]of this.updates.entries())if(this.uploadPlayerTextures(a,c[0],c[1]),this.updates.delete(a),2<++b)break}}uploadTexture(a,b){const c=this.gl;b&&(c.bindTexture(c.TEXTURE_2D,a),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,!0),c.texImage2D(c.TEXTURE_2D,0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,b),c.generateMipmap(c.TEXTURE_2D),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,c.LINEAR),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,c.LINEAR_MIPMAP_LINEAR),b.close())}uploadPlayerTextures(a=0,b,c){const d=this.gl,e=this.players.has(a)?this.players.get(a):{skin:b&&d.createTexture(),name:c&&d.createTexture()};c&&(e.name_dim=[c.width/512,c.height/512]),this.uploadTexture(e.skin,b),this.uploadTexture(e.name,c),this.players.set(a,e)}depthPeelRender(a=4,b,c){const d=this.gl;for(let e in b)d.useProgram(b[e]),d.uniformMatrix4fv(this.getUniform(b[e],"u_proj"),!1,this.proj),c[e](!0);let e,f,g,h;for(let j=0;j<a;j++){for(let a in e=j%2,f=1-e,d.bindFramebuffer(d.DRAW_FRAMEBUFFER,this.fbo.get("peel_depths")[f]),d.drawBuffers([d.COLOR_ATTACHMENT0]),d.clearColor(E,E,0,0),d.clear(d.COLOR_BUFFER_BIT),d.bindFramebuffer(d.DRAW_FRAMEBUFFER,this.fbo.get("peel_colors")[f]),d.drawBuffers([d.COLOR_ATTACHMENT0,d.COLOR_ATTACHMENT1]),d.clearColor(0,0,0,0),d.clear(d.COLOR_BUFFER_BIT),d.bindFramebuffer(d.DRAW_FRAMEBUFFER,this.fbo.get("peel_depths")[f]),d.drawBuffers([d.COLOR_ATTACHMENT0,d.COLOR_ATTACHMENT1,d.COLOR_ATTACHMENT2]),d.blendEquation(d.MAX),g=3*e,b)d.useProgram(b[a]),d.uniform1i(this.getUniform(b[a],"u_depth"),g),d.uniform1i(this.getUniform(b[a],"u_front_color"),g+1),c[a]();h=3*f,d.bindFramebuffer(d.DRAW_FRAMEBUFFER,this.fbo.get("blend_back")),d.drawBuffers([d.COLOR_ATTACHMENT0]),d.blendEquation(d.FUNC_ADD),d.blendFuncSeparate(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA,d.ONE,d.ONE_MINUS_SRC_ALPHA),d.useProgram(this.blend_prog),d.uniform1i(this.getUniform(this.blend_prog,"u_back_color"),h+2),d.bindVertexArray(this.quadVAO),d.drawArrays(d.TRIANGLES,0,6)}return h}}self.addEventListener("message",async function(a){const{data:b}=a,c=self.r=new H(b.offscreen);c.mouse.setBuffer(b.mouse),c.state.setBuffer(b.state),c.viewport.setBuffer(b.viewport),await c.initEngine(),self.addEventListener("message",a=>c.protocol.connect(a.data||"ws://localhost:3000")),self.postMessage("ready")},{once:!0}),b.exports=H},{"./cell":3,"./mouse":5,"./protocol":6,"./shaders":8,"./state":9,"./util":10,"./viewport":11,"./wasm-core":12}],8:[function(a,b){b.exports.CELL_VERT_SHADER_SOURCE=`#version 300 es
precision highp float;

uniform mat4 u_proj;

layout(location=0) in vec2 a_position;
layout(location=1) in vec3 a_data;

out vec2 v_texcoord;

void main() {

    vec4 world_pos = vec4(a_position * a_data.z + a_data.xy, -1.0 / pow(a_data.z, 0.333f), 1.0);
    gl_Position = u_proj * world_pos;

    // Map from -1 to 1 -> 0 to 1
    v_texcoord = (vec2(a_position.x, -a_position.y) + 1.0) / 2.0;
}
`,b.exports.CELL_FRAG_PEELING_SHADER_SOURCE=`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;

#define MAX_DEPTH 99999.0

uniform vec4 u_circle_color;

uniform sampler2D u_skin;
uniform sampler2D u_circle;

uniform sampler2D u_depth;
uniform sampler2D u_front_color;

in vec2 v_texcoord;

layout(location=0) out vec2 depth;  // RG32F, R - negative front depth, G - back depth
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;

void main() {

    float fragDepth = gl_FragCoord.z;   // 0 - 1

    ivec2 fragCoord = ivec2(gl_FragCoord.xy);
    vec2 lastDepth = texelFetch(u_depth, fragCoord, 0).rg;
    vec4 lastFrontColor = texelFetch(u_front_color, fragCoord, 0);

    // depth value always increases
    // so we can use MAX blend equation
    depth.rg = vec2(-MAX_DEPTH);

    // front color always increases
    // so we can use MAX blend equation
    frontColor = lastFrontColor;

    // back color is separately blend afterwards each pass
    backColor = vec4(0.0);

    float nearestDepth = -lastDepth.x;
    float furthestDepth = lastDepth.y;
    float alphaMultiplier = 1.0 - lastFrontColor.a;
    vec4 circle = texture(u_circle, v_texcoord);

    if (fragDepth < nearestDepth || fragDepth > furthestDepth || circle.a == 0.0f) {
        // Skip this depth since it's been peeled.
        return;
    }

    if (fragDepth > nearestDepth && fragDepth < furthestDepth) {
        // This needs to be peeled.
        // The ones remaining after MAX blended for 
        // all need-to-peel will be peeled next pass.
        depth.rg = vec2(-fragDepth, fragDepth);
        return;
    }
    vec4 skin = texture(u_skin, v_texcoord);
    vec4 color = vec4(mix(u_circle_color.rgb * u_circle_color.a, skin.rgb, skin.a), 
        mix(skin.a, circle.a, u_circle_color.a));

    if (fragDepth == nearestDepth) {
        frontColor.rgb += color.rgb * color.a * alphaMultiplier;
        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);
    } else {
        backColor += color;
    }
}
`,b.exports.NAME_VERT_SHADER_SOURCE=`#version 300 es
precision highp float;

uniform mat4 u_proj;
uniform vec4 u_dim;

layout(location=0) in vec2 a_position;
layout(location=1) in vec3 a_data;

out vec2 v_texcoord;

void main() {
    vec2 obj_pos = a_position * u_dim.xy * u_dim.z + vec2(0, u_dim.w);
    vec4 world_pos = vec4(obj_pos * a_data.z + a_data.xy, -1.0 / pow(a_data.z, 0.333f), 1.0);
    gl_Position = u_proj * world_pos;

    v_texcoord = (vec2(a_position.x, -a_position.y) + 1.0) / 2.0;
}
`,b.exports.NAME_FRAG_PEELING_SHADER_SOURCE=`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;

#define MAX_DEPTH 99999.0

uniform sampler2D u_name;

uniform sampler2D u_depth;
uniform sampler2D u_front_color;

in vec2 v_texcoord;

layout(location=0) out vec2 depth;  // RG32F, R - negative front depth, G - back depth
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;

void main() {
    float fragDepth = gl_FragCoord.z;   // 0 - 1

    ivec2 fragCoord = ivec2(gl_FragCoord.xy);
    vec2 lastDepth = texelFetch(u_depth, fragCoord, 0).rg;
    vec4 lastFrontColor = texelFetch(u_front_color, fragCoord, 0);

    // depth value always increases
    // so we can use MAX blend equation
    depth.rg = vec2(-MAX_DEPTH);

    // front color always increases
    // so we can use MAX blend equation
    frontColor = lastFrontColor;

    // back color is separately blend afterwards each pass
    backColor = vec4(0.0);

    float nearestDepth = -lastDepth.x;
    float furthestDepth = lastDepth.y;
    float alphaMultiplier = 1.0 - lastFrontColor.a;

    vec4 color = texture(u_name, v_texcoord);

    if (fragDepth < nearestDepth || fragDepth > furthestDepth || color.a == 0.0f) {
        // Skip this depth since it's been peeled.
        return;
    }

    if (fragDepth > nearestDepth && fragDepth < furthestDepth) {
        // This needs to be peeled.
        // The ones remaining after MAX blended for 
        // all need-to-peel will be peeled next pass.
        depth.rg = vec2(-fragDepth, fragDepth);
        return;
    }

    if (fragDepth == nearestDepth) {
        frontColor.rgb += color.rgb * color.a * alphaMultiplier;
        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);
    } else {
        backColor += color;
    }
}
`,b.exports.MASS_VERT_SHADER_SOURCE=`#version 300 es
precision highp float;
precision highp int;

uniform mat4 u_proj;
uniform vec2 u_uvs[48];

layout(location=0) in vec4 a_position;

out vec2 v_texcoord;
flat out int character;

void main() {
    vec4 world_pos = vec4(a_position.xy, -1.0 / pow(a_position.z, 0.333f), 1.0);
    gl_Position = u_proj * world_pos;
    character = int(a_position.w) >> 2;
    v_texcoord = u_uvs[int(a_position.w)];
}
`,b.exports.MASS_FRAG_PEELING_SHADER_SOURCE=`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler2DArray;

#define MAX_DEPTH 99999.0

uniform sampler2DArray u_mass_char;

uniform sampler2D u_depth;
uniform sampler2D u_front_color;

in vec2 v_texcoord;
flat in int character;

layout(location=0) out vec2 depth;  // RG32F, R - negative front depth, G - back depth
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;

void main() {
    float fragDepth = gl_FragCoord.z;   // 0 - 1

    ivec2 fragCoord = ivec2(gl_FragCoord.xy);
    vec2 lastDepth = texelFetch(u_depth, fragCoord, 0).rg;
    vec4 lastFrontColor = texelFetch(u_front_color, fragCoord, 0);

    // depth value always increases
    // so we can use MAX blend equation
    depth.rg = vec2(-MAX_DEPTH);

    // front color always increases
    // so we can use MAX blend equation
    frontColor = lastFrontColor;

    // back color is separately blend afterwards each pass
    backColor = vec4(0.0);

    float nearestDepth = -lastDepth.x;
    float furthestDepth = lastDepth.y;
    float alphaMultiplier = 1.0 - lastFrontColor.a;

    vec4 color = texture(u_mass_char, vec3(v_texcoord, character));

    if (fragDepth < nearestDepth || fragDepth > furthestDepth || color.a == 0.0f) {
        // Skip this depth since it's been peeled.
        return;
    }

    if (fragDepth > nearestDepth && fragDepth < furthestDepth) {
        // This needs to be peeled.
        // The ones remaining after MAX blended for 
        // all need-to-peel will be peeled next pass.
        depth.rg = vec2(-fragDepth, fragDepth);
        return;
    }

    if (fragDepth == nearestDepth) {
        frontColor.rgb += color.rgb * color.a * alphaMultiplier;
        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);
    } else {
        backColor += color;
    }
}
`,b.exports.QUAD_VERT_SHADER_SOURCE=`#version 300 es
layout(location=0) in vec4 aPosition;
void main() {
    gl_Position = aPosition;
}`,b.exports.BLEND_BACK_FRAG_SHADER_SOURCE=`#version 300 es
precision highp float;

uniform sampler2D u_back_color;

out vec4 fragColor;
void main() {
    fragColor = texelFetch(u_back_color, ivec2(gl_FragCoord.xy), 0);
    if (fragColor.a == 0.0) { 
        discard;
    }
}
`,b.exports.FINAL_FRAG_SHADER_SOURCE=`#version 300 es
precision highp float;

uniform sampler2D u_front_color;
uniform sampler2D u_back_color;

out vec4 fragColor;
void main() {
    ivec2 fragCoord = ivec2(gl_FragCoord.xy);
    vec4 frontColor = texelFetch(u_front_color, fragCoord, 0);
    vec4 backColor = texelFetch(u_back_color, fragCoord, 0);
    float alphaMultiplier = 1.0 - frontColor.a;

    fragColor = vec4(
        frontColor.rgb + alphaMultiplier * backColor.rgb,
        frontColor.a + backColor.a
    );
}`},{}],9:[function(a,b){b.exports=class{constructor(){this.setBuffer()}setBuffer(a=new SharedArrayBuffer(6)){this.sharedBuffer=a,this.buffer=new Uint8Array(this.sharedBuffer)}get spectate(){return Atomics.load(this.buffer,0)}set spectate(a){Atomics.store(this.buffer,0,a)}get splits(){return Atomics.load(this.buffer,1)}set splits(a){Atomics.add(this.buffer,1,a)}get ejects(){return Atomics.load(this.buffer,2)}set ejects(a){Atomics.add(this.buffer,2,a)}get macro(){return Atomics.load(this.buffer,3)}set macro(a){Atomics.store(this.buffer,3,a)}get respawn(){return Atomics.load(this.buffer,4)}set respawn(a){Atomics.store(this.buffer,4,a)}get focused(){return Atomics.load(this.buffer,5)}set focused(a){Atomics.store(this.buffer,5,a)}exchange(){return{spectate:Atomics.exchange(this.buffer,0,0),splits:Atomics.exchange(this.buffer,1,0),ejects:Atomics.exchange(this.buffer,2,0),macro:this.macro,respawn:Atomics.exchange(this.buffer,4,0)}}}},{}],10:[function(a,b){b.exports.pick=a=>a[~~(Math.random()*a.length)],b.exports.makeProgram=(a,b,c)=>{const d=a.createShader(a.VERTEX_SHADER),e=a.createShader(a.FRAGMENT_SHADER);a.shaderSource(d,b),a.shaderSource(e,c),a.compileShader(d),a.compileShader(e);const f=a.createProgram();if(a.attachShader(f,d),a.attachShader(f,e),a.linkProgram(f),!a.getProgramParameter(f,a.LINK_STATUS))throw console.error(`vs info-log: ${a.getShaderInfoLog(d)}\n`+`info-log: ${a.getShaderInfoLog(e)}`),new Error(`prog link failed: ${a.getProgramInfoLog(f)}`);return f};const c=[[255,0,0],[255,128,0],[255,255,0],[128,255,0],[0,255,0],[0,255,128],[0,255,255],[0,128,255],[127,0,255],[255,0,255],[255,0,127]].map(a=>a.map(a=>a/255));b.exports.getColor=a=>c[a%c.length]},{}],11:[function(a,b){b.exports=class{constructor(){this.setBuffer()}setBuffer(a=new SharedArrayBuffer(8)){this.sharedBuffer=a,this.buffer=new Int32Array(this.sharedBuffer)}get width(){return Atomics.load(this.buffer,0)}set width(a){Atomics.store(this.buffer,0,a)}get height(){return Atomics.load(this.buffer,1)}set height(a){Atomics.store(this.buffer,1,a)}}},{}],12:[function(a,b){b.exports=class{constructor(a){this.renderer=a}async load(a=1024){if(this.loading||this.instance)return!1;this.loading=!0;const b=await fetch("/static/wasm/client.wasm"),c=new WebAssembly.Memory({initial:a,maximum:a});return this.instance=await WebAssembly.instantiate(await WebAssembly.compile(await b.arrayBuffer()),{env:{memory:c,log_add_packet:(a,b,c,d,e)=>{console.log("Add Packet: ",{id:a,type:b,x:c,y:d,size:e})}}}),this.buffer=c.buffer,this.HEAPU8=new Uint8Array(c.buffer),this.HEAPU16=new Uint16Array(c.buffer),this.HEAPF32=new Float32Array(c.buffer),this.HEAPU32=new Uint32Array(c.buffer),this.loading=!1,!0}}},{}]},{},[7]);